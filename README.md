Виконала Миронович Ольга 
Лаба 1
Дано масив цілих чисел nums та ціле число target. Перевірте, чи існують два різних елементи в масиві nums, сума яких дорівнює target. Якщо такі елементи існують, поверніть індекси цих елементів.

Припустимо, що кожен масив цілих чисел nums може мати більше одного рішення, або жодного, і той самий елемент не може бути використаний двічі. Якщо масив не містить двох чисел, сума яких рівна target - тоді слід повернути значення -1

Приклади:

Вхідні дані: nums = [2,7,11,15], target = 9 Результат: [0,1] Пояснення: Елементи nums [0] + nums[1] = 2 + 7 = 9, їх сума рівна target.

Вхідні дані: nums = [3,2,4], target = 6 Результат: [1,2] Пояснення: Елементи nums[1] + nums[2] = 2 + 4 = 6, їх сума рівна target.

Вхідні дані: nums = [3,3], target = 6 Результат: [0,1] Пояснення: Елементи nums[0] + nums[1] = 3 + 3 = 6, їх сума рівна target.

Вхідні дані: nums = [3,5], target = 6 Результат: -1 Пояснення: Немає елементів, сума яких рівна target.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище
Лаба 2
Припустимо, компанія, в якій ви працюєте, розробляє електронний календар. У календарі є функція, що показує, коли різні команди програмістів будуть зайняті протягом будь-якої зустрічі.

Ті періоди, коли команда зайнята, на календарі позначені як діапазони часу, наприклад, з 10:00 до 12:30 або з 12:30 до 13:00. У вашій програмі проміжок часу представлений у вигляді пари з двох цілих чисел. Число означає номер 30-хвилинного блоку, який йде після 9:00 ранку. Наприклад, кортеж (2, 4) означає діапазон з 10:00 до 11:00, а (0, 1) - це проміжок 9:00-9:30.

Вам потрібно написати функцію, яка повинна спростити вивід інформації таким чином, що якщо команда зайнята в проміжках з 10:00 до 12:30 і з 12:30 до 13:00, то це має відображатись  як 10: 00-13: 00.

Приклад:

на вході вашої функції невпорядкований масив з кортежів [(0, 1), (3, 5), (4, 8), (10, 12), (9, 10)],

Результат: Ваша функція має повернути впорядкований масив  [(0, 1), (3, 8), (9, 12)].

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище

Лаба 3
Для бінарного дерева знайдіть суму всіх глибин усіх вузлів. Глибина вузла - це кількість ребер, які потрібно пройти від кореня дерева, щоб досягти цього вузла.

Ваше завдання полягає в написанні функції, яка обчислює та повертає суми глибин для всіх вузлів у бінарному дереві

Приклад: Розглянемо таке бінарне дерево:

    1
   / \
  2   3
 / \
4   5
Глибина вузла 1 -0, глибина вузла 2 та 3 становить 1, а глибина вузлів 4 та 5 - 2. Сума глибин всіх вузлів дорівнює 0 + 1 + 1 + 2 + 2 = 6.

Функція отримує на вхід корінь бінарного дерева, який має наступний вигляд:

class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

 Ваша функція має мати такий вигляд:  

def sum_of_depths(root: TreeNode) -> int:
    # ваш код
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу TreeNode наступним чином:

root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
