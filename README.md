## Лабораторні роботи з дисципліни "Алгоритми і структури даних"

## Виконала: Миронович Ольга Володимирівна(ІР-24)
## Лабораторна робота №1 (Варіант 2 Рівень 1)

Дано масив цілих чисел `nums` та ціле число `target`. Перевірте, чи існують два різних елементи в масиві `nums`, сума яких дорівнює `target`. Якщо такі елементи існують, поверніть індекси цих елементів.

Припустимо, що кожен масив цілих чисел `nums` може мати більше одного рішення, або жодного, і той самий елемент не може бути використаний двічі. Якщо масив не містить двох чисел, сума яких рівна `target` - тоді слід повернути значення `-1`

Приклади:

Вхідні дані: `nums = [2,7,11,15], target = 9`
Результат: `[0,1]`
Пояснення: Елементи `nums [0]` + `nums[1]` = 2 + 7 = 9, їх сума рівна target.

Вхідні дані: `nums = [3,2,4], target = 6`
Результат: `[1,2]`
Пояснення: Елементи `nums[1]` + `nums[2]` = 2 + 4 = 6, їх сума рівна target.

Вхідні дані: `nums = [3,3], target = 6`
Результат: `[0,1]`
Пояснення: Елементи `nums[0]` + `nums[1]` = 3 + 3 = 6, їх сума рівна target.

Вхідні дані: `nums = [3,5], target = 6`
Результат:  -1
Пояснення: Немає елементів, сума яких рівна target.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
## Лабораторна робота №2 (Варіант 2 Рівень 1)
Припустимо, компанія, в якій ви працюєте, розробляє електронний календар. У календарі є функція, що показує, коли різні команди програмістів будуть зайняті протягом будь-якої зустрічі.

Ті періоди, коли команда зайнята, на календарі позначені як діапазони часу, наприклад, з 10:00 до 12:30 або з 12:30 до 13:00. У вашій програмі проміжок часу представлений у вигляді пари з двох цілих чисел. Число означає номер 30-хвилинного блоку, який йде після 9:00 ранку. Наприклад, кортеж (2, 4) означає діапазон з 10:00 до 11:00, а (0, 1) - це проміжок 9:00-9:30.

Вам потрібно написати функцію, яка повинна спростити вивід інформації таким чином, що якщо команда зайнята в проміжках з 10:00 до 12:30 і з 12:30 до 13:00, то це має відображатись  як 10: 00-13: 00.

Приклад:

на вході вашої функції невпорядкований масив з кортежів [(0, 1), (3, 5), (4, 8), (10, 12), (9, 10)],

Результат: Ваша функція має повернути впорядкований масив  [(0, 1), (3, 8), (9, 12)].

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище

## Лабораторна робота №3 (Варіант 2 Рівень 2)
Для бінарного дерева знайдіть суму всіх глибин усіх вузлів. Глибина вузла - це кількість ребер, які потрібно пройти від кореня дерева, щоб досягти цього вузла.

Ваше завдання полягає в написанні функції, яка обчислює та повертає суми глибин для всіх вузлів у бінарному дереві

 Приклад: Розглянемо таке бінарне дерево:
 ```
    1
   / \
  2   3
 / \
4   5
```
Глибина вузла 1 -0, глибина вузла 2 та 3 становить 1, а глибина вузлів 4 та 5 - 2. Сума глибин всіх вузлів дорівнює 0 + 1 + 1 + 2 + 2 = 6.

Функція отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
 class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```
Ваша функція має мати такий вигляд:
```
 def sum_of_depths(root: TreeNode) -> int:
    # ваш код

```

 Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу TreeNode наступним чином:
    
```
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)

```
## Лабораторна робота №4 (Варіант 3 Рівень 1)
Дано двійкове дерево, знайти його мінімальну глибину. Мінімальна глибина — це загальна кількість вузлів уздовж найкоротшого шляху від кореневого вузла до найближчого кінцевого вузла.

Наприклад, мінімальна глибина наступного бінарного дерева дорівнює 3. Найкоротший шлях — 1 —> 3 —> 6.

Для представлення графу слід використати список суміжності,дані зчитуються з файлу input.txt

input.txt містить:
1 #корінь дереа
1,2 # список ребер, де порядок вершин визначає напрямок. В даному випадку ребро направлене від 1 до 2
1,3
2,4
…


Результат (мінімальна глибина дерева) слід вивести у файл output.txt

## Лабораторна робота №5 (Варіант 2 Рівень 3)
Код задачi: CAREER
Ви хочете зробити кар’єру у великiй корпорацiї, яка має складну iєрархiчну структуру
та багато посад. Проте, читаючи вiдгуки працiвникiв на GlassDoor, ви дiзнаєтеся,
що рiзнi посади в цiй компанiї приносять зовсiм рiзну кiлькiсть корисного досвiду,
тому є сенс ретельно обирати, на яких посадах ви хочете працювати.
Органiзацiйна структура компанiї має форму пiрамiди, де вищий рiвень має рiвно
на 1 посаду менше, нiж нижчий. Досвiд, який можна здобути на кожнiй посадi, а
також способи пiдвищення вказанi на схемi:
              4

        3          1

   2          1          5

1        3         2        1

Працiвник може бути переведений тiльки на вищу посаду (з вищої на нижчу рухатись
не дозволяється).
Знаючи досвiд, який можна здобути на кожнiй посадi в компанiї, визначте максимальну
суму досвiду, яку ви можете здобути, почавши працювати на найнижчому рiвнi.
Вхiднi данi
Вхiдний файл career .in складається з L + 1 рядкiв.
• Перший рядок мiстить L — кiлькiсть органiзацiйних рiвнiв в компанiї.
1 ≤ L ≤ 1000
• Наступнi L рядкiв мiстять 1, 2, 3, ..., L−2, L−1, L натуральних чисел E — досвiд
для кожної посади на даному рiвнi.
0 ≤ E < 10000
Вихiднi данi
Вихiдний файл career .out повинен мiстити одне цiле число — максимальний сумарний
досвiд, який можливо здобути в цiй компанiї.


Приклад 1
career .in
4
4
3 1
2 1 5
1 3 2 1
career .out
12
